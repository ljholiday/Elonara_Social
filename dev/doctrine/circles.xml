<doctrine name="Circles Relationship Engine" version="1.0">

  <summary>
    Circles in Elonara Social are modeled as a bidirectional graph of users.
    Only direct ("Inner") relationships are stored.
    Higher-level circles (Trusted, Extended) are derived dynamically by hop distance.
    This replaces all prior static circle field logic.
  </summary>

  <principles>
    <rule id="CIR-001">All circle relationships are bi-directional.</rule>
    <rule id="CIR-002">Only direct (1-hop) relationships are stored in the database.</rule>
    <rule id="CIR-003">Trusted and Extended circles are computed using hop traversal.</rule>
    <rule id="CIR-004">Circle depth is a numeric score (hop distance), not a field value.</rule>
    <rule id="CIR-005">Visibility and access are determined by hop score thresholds.</rule>
    <rule id="CIR-006">Circle cache generation is optional and asynchronous.</rule>
  </principles>

  <schema>
    <table name="user_links" purpose="Stores all direct mutual Inner relationships.">
      <field name="user_id" type="INT" required="true"/>
      <field name="peer_id" type="INT" required="true"/>
      <field name="created_at" type="TIMESTAMP" default="CURRENT_TIMESTAMP"/>
      <primary key="user_id,peer_id"/>
      <constraint type="bidirectional">For every (user_id, peer_id), an inverse (peer_id, user_id) must exist.</constraint>
    </table>

    <table name="user_circle_cache" purpose="Optional cache of computed circles.">
      <field name="user_id" type="INT" required="true"/>
      <field name="circle_json" type="JSON" required="true"
             example='{"inner":[2,3],"trusted":[4,5],"extended":[6]}'/>
      <field name="updated_at" type="TIMESTAMP" default="CURRENT_TIMESTAMP"/>
      <primary key="user_id"/>
    </table>
  </schema>

  <logic>
    <concept name="hop_distance">
      <definition>
        Hop distance is the minimum number of edges between two users in the user_links graph.
        Inner = 1, Trusted = 2, Extended = 3.
      </definition>
      <formula>
        circle_level = {
          if (hops <= 1) then 'inner';
          if (hops == 2) then 'trusted';
          if (hops == 3) then 'extended';
        }
      </formula>
    </concept>

    <process name="circle_resolution" purpose="Calculate visible members up to a hop depth.">
      <input>user_id, max_hops (default=3)</input>
      <output>peer_id => hop_distance map</output>
      <algorithm type="breadth_first_search">
        <step>Start with queue [user_id, depth=0]</step>
        <step>For each peer connected to current node, if not visited, set depth+1</step>
        <step>Stop traversal when depth >= max_hops</step>
      </algorithm>
    </process>

    <process name="circle_cache_refresh" purpose="Regenerate cache JSON for affected users.">
      <trigger>Insert or delete in user_links.</trigger>
      <action>Recompute hops up to depth 3 and persist JSON to user_circle_cache.</action>
      <frequency>Async background task, max once per user per minute.</frequency>
    </process>
  </logic>

  <queries>
    <query name="find_inner" sql="SELECT peer_id FROM user_links WHERE user_id=:id"/>
    <query name="find_trusted" sql="
      SELECT DISTINCT l2.peer_id
      FROM user_links l1
      JOIN user_links l2 ON l1.peer_id = l2.user_id
      WHERE l1.user_id=:id AND l2.peer_id!=:id"/>
    <query name="find_extended" sql="
      SELECT DISTINCT l3.peer_id
      FROM user_links l1
      JOIN user_links l2 ON l1.peer_id = l2.user_id
      JOIN user_links l3 ON l2.peer_id = l3.user_id
      WHERE l1.user_id=:id AND l3.peer_id!=:id"/>
  </queries>

  <performance>
    <metric name="write_overhead" value="O(1)" note="Only direct link insertions."/>
    <metric name="read_complexity" value="O(n × d)" note="n = peers, d = hop depth ≤ 3."/>
    <metric name="cache_hit_ratio" value="0.9" note="Once warmed, cached lookups dominate."/>
  </performance>

  <integration>
    <usage module="Conversations">Resolve participants dynamically by hop score, no DB writes on reply.</usage>
    <usage module="Invitations">When accepted, insert mutual user_links pairs (1-hop Inner).</usage>
    <usage module="Communities">Restrict visibility and membership options by hop threshold.</usage>
  </integration>

</doctrine>

